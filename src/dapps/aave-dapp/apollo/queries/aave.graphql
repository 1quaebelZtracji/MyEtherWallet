subscription ReserveRatesHistoryUpdate($reserveAddress: String!) {
  reserveParamsHistoryItems(where: { reserve: $reserveAddress }, first: 100, orderBy: timestamp, orderDirection: desc){
    ...ReserveRatesHistoryData
  }
}

subscription UserPositionUpdateSubscription($userAddress: String!, $pool: String) {
  userReserves(where: {user: $userAddress, pool: $pool}) {
    ...UserReserveData
  }
}

subscription UsdPriceEth {
  priceOracle(id: "1") {
    usdPriceEth
  }
}

fragment ReserveRatesHistoryData on ReserveParamsHistoryItem {
  variableBorrowRate
  stableBorrowRate
  liquidityRate
  utilizationRate
  timestamp
}

fragment UserReserveData on UserReserve {
  scaledATokenBalance
  reserve {
    id
    underlyingAsset
    name
    symbol
    decimals
    liquidityRate
    reserveLiquidationBonus
    lastUpdateTimestamp
    aToken {
      id
    }
  }
  usageAsCollateralEnabledOnUser
  stableBorrowRate
  stableBorrowLastUpdateTimestamp
  principalStableDebt
  scaledVariableDebt
  variableBorrowIndex
  lastUpdateTimestamp
}

fragment ReserveData on Reserve {
  id
  underlyingAsset
  name
  symbol
  decimals
  isActive
  isFrozen
  usageAsCollateralEnabled
  borrowingEnabled
  stableBorrowRateEnabled
  baseLTVasCollateral
  optimalUtilisationRate
  averageStableRate
  stableRateSlope1
  stableRateSlope2
  baseVariableBorrowRate
  variableRateSlope1
  variableRateSlope2
  variableBorrowIndex
  variableBorrowRate
  totalScaledVariableDebt
  liquidityIndex
  reserveLiquidationThreshold
  aToken {
    id
  }
  vToken {
    id
  }
  sToken {
    id
  }
  availableLiquidity
  stableBorrowRate
  liquidityRate
  totalPrincipalStableDebt
  totalLiquidity
  utilizationRate
  reserveLiquidationBonus
  price {
    priceInEth
  }
  lastUpdateTimestamp
  stableDebtLastUpdateTimestamp
  reserveFactor
}